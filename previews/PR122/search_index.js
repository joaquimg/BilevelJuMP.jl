var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Example","page":"Manual","title":"Example","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JuMP, BilevelJuMP, Cbc\n\nmodel = BilevelModel(Cbc.Optimizer, mode = BilevelJuMP.SOS1Mode())\n\n@variable(Lower(model), x)\n@variable(Upper(model), y)\n\n@objective(Upper(model), Min, 3x + y)\n@constraints(Upper(model), begin\n    x <= 5\n    y <= 8\n    y >= 0\nend)\n\n@objective(Lower(model), Min, -x)\n@constraints(Lower(model), begin\n     x +  y <= 8\n    4x +  y >= 8\n    2x +  y <= 13\n    2x - 7y <= 0\nend)\n\noptimize!(model)\n\nobjective_value(model) # = 3 * (3.5 * 8/15) + 8/15 # = 6.13...\nvalue(x) # = 3.5 * 8/15 # = 1.86...\nvalue(y) # = 8/15 # = 0.53...","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The option BilevelJuMP.SOS1Mode() indicates that the solution method used will be a KKT reformulation emplying SOS1 to model complementarity constraints and solve the problem with MIP solvers (Cbc, Xpress, Gurobi, CPLEX, SCIP).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Alternatively, the option BilevelJuMP.IndicatorMode() is almost equivalent to the previous. The main difference is that it relies on Indicator constraints instead. This kind of constraints is available in some MIP solvers.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A third and classic option it the BilevelJuMP.FortunyAmatMcCarlMode(), which relies on the Fortuny-Amat and McCarl big-M method that requires a MIP solver with very basic functionality, i.e., just binary variables are needed. The main drawback of this method is that one must provide bounds for all primal and dual variables. However, if the bounds are good, this method can be more efficient than the previous. Bound hints to compute the big-Ms can be passed with the methods: set_primal_(upper\\lower)_bound_hint(variable, bound), for primals; and set_dual_(upper\\lower)_bound(constraint, bound) for duals. We can also call FortunyAmatMcCarlMode(primal_big_M = vp, dual_big_M = vd), where vp and vd are, repspectively, the big M fallback values for primal and dual variables, these are used when some variables have no given bounds, otherwise the given bounds are used instead.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Another option is BilevelJuMP.ProductMode() that reformulates the complementarity constraints as products so that the problem can be solved by NLP (Ipopt, KNITRO) solvers or even MIP solvers with the aid of binary expansions (see QuadraticToBinary.jl). Note that binary expansions require variables to have upper and lower bounds.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally, one can use BilevelJuMP.MixedMode(default = mode) where mode is one of the other modes described above. With this method it is possible to set complementarity reformulations per constraint with BilevelJuMP.set_mode(ctr, mode).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"An alternative to complementarity constraint reformulation is the Strong Duality reformulation which add the constraint enforcing primal dual equality. The option is BilevelJuMP.StrongDualityMode(eps) where eps is the tolance on the enforcing constraint.","category":"page"},{"location":"manual/#Note-on-[QuadraticToBinary.jl](https://github.com/joaquimg/QuadraticToBinary.jl)","page":"Manual","title":"Note on QuadraticToBinary.jl","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"QuadraticToBinary.jl is a package that converts quadratic terms in constraints and objective. To do so the pack acts like a solver on top of the real solver and most data is forwarded directly to the solver itself. For many solvers it is enough to use:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"SOLVER = Xpress.Optimizer()\nQ_SOLVER = QuadraticToBinary.Optimizer{Float64}(SOLVER)\nBilevelModel(Q_SOLVER, mode = BilevelJuMP.ProductMode(1e-5))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"However, this might lead to some solver not supporting certain functionality like Cbc. In this case we need to:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"SOLVER = Cbc.Optimizer()\nCACHED_SOLVER = MOI.Utilities.CachingOptimizer(\n    MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}()), SOLVER)\nQ_SOLVER = QuadraticToBinary.Optimizer{Float64}(CACHED_SOLVER)\nBilevelModel(()->Q_SOLVER, mode = BilevelJuMP.ProductMode(1e-5))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that we used ()->Q_SOLVER instead of just Q_SOLVER because BilevelModel requires as constructor and not an instance of an object.","category":"page"},{"location":"manual/#Advanced-Features","page":"Manual","title":"Advanced Features","text":"","category":"section"},{"location":"manual/#Lower-level-dual-variables","page":"Manual","title":"Lower level dual variables","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Suppose you have a constraint b in the lower level:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@constraint(Lower(model), b, ...)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is possible to access the dual variable of b to use it in the upper level:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@variable(Upper(model), lambda, DualOf(b))","category":"page"},{"location":"manual/#Conic-lower-level","page":"Manual","title":"Conic lower level","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"BilevelJuMP allows users to write conic models in the lower level. However, solving this kind of problems is much harder and requires complex solution methods. Mosek's Conic MIP can be used with the aid of QuadraticToBinary.jl.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is also possible to solve Second Order Cone constrained models with Ipopt. In this case we need to add a special, non-standard bridge, to Ipopt as follows:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"IPO_OPT = Ipopt.Optimizer(print_level=0)\nIPO = MOI.Bridges.Constraint.SOCtoNonConvexQuad{Float64}(IPO_OPT)\nBilevelModel(()->IPO, mode = BilevelJuMP.ProductMode(1e-5))","category":"page"},{"location":"#BilevelJuMP.jl-Documentation","page":"Home","title":"BilevelJuMP.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BilevelJuMP is a package for modeling and solving bilevel optimization problems in Julia. As an extension of the JuMP package, BilevelJuMP allows users to employ the usual JuMP syntax with minor modifications to describe the problem and query solutions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BilevelJuMP is built on top of MathOptInterface and makes strong use of its features to reformulate the problem as a single level problem and solve it with available MIP, NLP, and other solvers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The currently available methods are based on re-writing the problem using the KKT conditions of the lower level. For that we make strong use of Dualization.jl","category":"page"}]
}
